/*
 * Copyright 2019 Distributed Systems Group
 *
 * <p>Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * <p>http://www.apache.org/licenses/LICENSE-2.0
 *
 * <p>Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package simblock.node.consensus;

import java.math.BigInteger;
import java.util.List;
import java.util.Random;
import simblock.block.Block;
import simblock.block.IBlockIdGenerator;
import simblock.block.ProofOfWorkBlock;
import simblock.node.AbstractNode;
import simblock.simulator.Timer;
import simblock.simulator.interfaces.IStochasticProcess;
import simblock.task.AbstractMintingTask;
import simblock.task.GenesisMiningTask;
import simblock.task.MiningTask;

/**
 * The type Proof of work.
 */
public class ProofOfWork extends AbstractConsensusAlgo implements IStochasticProcess {
  /**
   * Instantiates a new Proof of work consensus algorithm.
   *
   * @param selfNode the self node
   */
  private INetworkAware networkAware;
  private Random random;
  private IBlockIdGenerator generator;

  /**
   * Instantiates a new PoW consensus algo.
   *
   * @param selfNode     the node following this algorithm
   * @param timer        the simulation timer used to register tasks
   * @param networkAware entity holding global node network state
   * @param random       the shared random instance
   * @param generator    the block id generator
   */
  public ProofOfWork(AbstractNode selfNode, Timer timer, INetworkAware networkAware, Random random, IBlockIdGenerator generator) {
    super(selfNode, timer);

    this.random = random;
    this.networkAware = networkAware;
    this.generator = generator;
  }

  /**
   * Mints a new block by simulating Proof of Work.
   */
  @Override
  public MiningTask minting() {
    AbstractNode selfNode = this.getSelfNode();
    ProofOfWorkBlock parent = (ProofOfWorkBlock) selfNode.getBlock();

    // I think this increases lineraly since it is set when mining the genesis node and never modified after that
    // Actually, it might stay static
    BigInteger difficulty = parent.getNextDifficulty(); 
    double modifiedDifficulty = 1.0 / difficulty.doubleValue(); // Why am I modifying this?
    double newRandom = this.getRandomGenerator().nextDouble();
    MiningTask newMiningTask = null;

    // Not sure of the significance of this calculation
    if (modifiedDifficulty > Math.pow(2, -53)) {

      // Create an expotential distribution of mining times
      // See https://en.wikipedia.org/wiki/Inverse_transform_sampling
      //Further,
      //we simulate the time when the mining becomes successful
      //by deriving a random number that follows that distribution
      //random number are generated by obtaining the geometric distribution from the difficulty of block generation and the hash rate of the node.
      var myInterval = (long) (Math.log(newRandom) / Math.log(1.0 - modifiedDifficulty) 
                               / selfNode.getMiningPower());

      newMiningTask = new MiningTask(selfNode, 
                                     myInterval,
                                     difficulty, 
                                     getTimer(), 
                                     generator);
    }
    
    return newMiningTask;                          
  }

  /**
   * Tests if the receivedBlock is valid with regards to the current block. The receivedBlock
   * is valid if it is an instance of a Proof of Work block and the received block needs to have
   * a bigger difficulty than its parent next difficulty and a bigger total difficulty compared to
   * the current block.
   *
   * @param receivedBlock the received block
   * @param currentBlock  the current block
   * @return true if block is valid false otherwise
   */
  @Override
  public boolean isReceivedBlockValid(Block receivedBlock, Block currentBlock) {
    if (!(receivedBlock instanceof ProofOfWorkBlock)) {
      return false;
    }
    ProofOfWorkBlock recPoWBlock = (ProofOfWorkBlock) receivedBlock;
    ProofOfWorkBlock currPoWBlock = (ProofOfWorkBlock) currentBlock;
    int receivedBlockHeight = receivedBlock.getHeight();
    ProofOfWorkBlock receivedBlockParent = receivedBlockHeight == 0 ? null :
        (ProofOfWorkBlock) receivedBlock.getBlockWithHeight(receivedBlockHeight - 1);

    //TODO - dangerous to split due to short circuit operators being used, refactor?
    boolean difficultyHasNotDecreased = (receivedBlockHeight == 0 
                                         || recPoWBlock.getDifficulty().compareTo(receivedBlockParent.getNextDifficulty()) >= 0);
    boolean totalDifficultyHasIncreased = (currentBlock == null 
                                           || recPoWBlock.getTotalDifficulty().compareTo(currPoWBlock.getTotalDifficulty()) >= 0);
    // Total difficulty is currently the same. Is this valid?
    return difficultyHasNotDecreased && totalDifficultyHasIncreased;
  }

  @Override
  public AbstractMintingTask genesisBlockTask() {
    BigInteger genesisNextDifficulty = BigInteger.valueOf(getTotalMiningPower() * networkAware.getTargetInterval());

    return new GenesisMiningTask(
        this.getSelfNode(), 0, getTimer(), genesisNextDifficulty, generator
    );
  }

  /**
   * Returns the total mining power contained within the provided nodes.
   *
   * @param nodes the nodes
   * @return the total mining power
   */
  public long getTotalMiningPower(List<AbstractNode> nodes) {
    long totalMiningPower = 0;
    for (AbstractNode node : nodes) {
      totalMiningPower += node.getMiningPower();
    }

    return totalMiningPower;
  }

  public long getTotalMiningPower() {
    return getTotalMiningPower(this.networkAware.getSimulatedNodes());
  }

  @Override
  public Random getRandomGenerator() {
    return this.random;
  }

}
